"""
Router de reportes y estadísticas
- Reportes originales (Siniestros)
- Reportes de Índice de Seguridad (Combinado)
"""

from fastapi import APIRouter, Depends, Query, HTTPException, status
from fastapi.responses import JSONResponse
from fastapi.encoders import jsonable_encoder
from sqlalchemy import text
from sqlalchemy.ext.asyncio import AsyncSession
from typing import List, Dict, Optional
from decimal import Decimal
import logging
from datetime import timedelta, date, time

from config.database import get_db
# Importamos AMBOS servicios
from services import reportes as reportes_service
from services import analisis_seguridad # <--- NUEVO IMPORT
from services.auth import obtener_usuario_actual # <--- USAMOS LA DEPENDENCIA CORREGIDA

router = APIRouter(prefix="/reportes", tags=["Reportes y Análisis"])

def _serialize_row(row) -> Dict:
    if not row:
        return {}
    d = dict(row)
    for k, v in list(d.items()):
        if isinstance(v, Decimal):
            try:
                if v == v.to_integral_value():
                    d[k] = int(v)
                else:
                    d[k] = float(v)
            except Exception:
                d[k] = float(v)
    return d

def _serialize_rows(rows) -> List[Dict]:
    return [_serialize_row(r) for r in rows]

async def _table_exists(db: AsyncSession, table_name: str) -> bool:
    sql = text("""
        SELECT COUNT(*) FROM information_schema.tables
        WHERE table_schema = DATABASE() AND table_name = :t
    """)
    r = await db.execute(sql, {"t": table_name})
    cnt = r.scalar()
    try:
        return int(cnt) > 0
    except Exception:
        return bool(cnt)

async def _column_exists(db: AsyncSession, table_name: str, column_name: str) -> bool:
    sql = text("""
        SELECT COUNT(*) FROM information_schema.columns
        WHERE table_schema = DATABASE() AND table_name = :t AND column_name = :c
    """)
    r = await db.execute(sql, {"t": table_name, "c": column_name})
    cnt = r.scalar()
    try:
        return int(cnt) > 0
    except Exception:
        return bool(cnt)

@router.get("/resumen-general")
async def resumen_general(db: AsyncSession = Depends(get_db)):
    try:
        sql = text("""
          SELECT COUNT(*) AS total_siniestros,
                 COALESCE(SUM(victimas_fatales),0) AS total_fallecidos,
                 COALESCE(SUM(heridos),0) AS total_heridos
          FROM siniestros;
        """)
        result = await db.execute(sql)
        row = result.mappings().first()
        return JSONResponse(content=_serialize_row(row))
    except Exception as e:
        logging.exception("Error en resumen_general")
        return JSONResponse(content={"detail": "Error interno"}, status_code=500)

@router.get("/siniestros-por-zona")
async def siniestros_por_zona(db: AsyncSession = Depends(get_db)):
    """
    Consulta adaptativa para devolver siniestros por 'zona'.
    - Si existe tabla 'zonas' y columna 'zona_id' en siniestros: hace JOIN y usa zonas.nombre.
    - Si no, intenta agrupar por 'avenida' (avenidas/avenida_id).
    - Si ninguna columna relacionada existe, agrupa por fecha (día) como fallback simple.
    """
    try:
        # preferir zonas
        zonas_table = await _table_exists(db, "zonas")
        has_zona_col = await _column_exists(db, "siniestros", "zona_id")
        if zonas_table and has_zona_col:
            sql = text("""
              SELECT z.nombre AS zona, COUNT(*) AS total
              FROM siniestros s
              JOIN zonas z ON s.zona_id = z.id
              GROUP BY z.nombre
              ORDER BY total DESC;
            """)
            result = await db.execute(sql)
            rows = result.mappings().all()
            return JSONResponse(content=_serialize_rows(rows))

        # intentar avenidas (muchos modelos usan avenida_id)
        avenidas_table = await _table_exists(db, "avenidas")
        has_avenida_col = await _column_exists(db, "siniestros", "avenida_id")
        if avenidas_table and has_avenida_col:
            sql = text("""
              SELECT a.nombre AS zona, COUNT(*) AS total
              FROM siniestros s
              JOIN avenidas a ON s.avenida_id = a.id
              GROUP BY a.nombre
              ORDER BY total DESC;
            """)
            result = await db.execute(sql)
            rows = result.mappings().all()
            return JSONResponse(content=_serialize_rows(rows))

        # si no hay tablas relacionadas, agrupar por la columna disponible (tipo_id / usuario_id) o por día
        if await _column_exists(db, "siniestros", "tipo_id"):
            sql = text("""
              SELECT s.tipo_id AS zona, COUNT(*) AS total
              FROM siniestros s
              GROUP BY s.tipo_id
              ORDER BY total DESC;
            """)
            result = await db.execute(sql)
            rows = result.mappings().all()
            return JSONResponse(content=_serialize_rows(rows))

        # fallback final: contar por fecha (por día) para al menos devolver algo
        sql = text("""
          SELECT DATE(fecha) AS zona, COUNT(*) AS total
          FROM siniestros
          GROUP BY DATE(fecha)
          ORDER BY total DESC
          LIMIT 50;
        """)
        result = await db.execute(sql)
        rows = result.mappings().all()
        return JSONResponse(content=_serialize_rows(rows))
    except ProgrammingError:
        logging.exception("ProgrammingError en siniestros_por_zona")
        return JSONResponse({"detail": "Error de consulta en la base de datos"}, status_code=500)
    except Exception:
        logging.exception("Error fallback siniestros_por_zona")
        return JSONResponse({"detail": "Error interno"}, status_code=500)

@router.get("/estadisticas-por-tipo")
async def estadisticas_por_tipo(db: AsyncSession = Depends(get_db)):
    """
    Intenta estadísticas por tipo con join a tipos_siniestro.
    Si la tabla no existe, fallback por tipo_id.
    """
    try:
        sql = text("""
          SELECT t.nombre AS tipo, COUNT(*) AS total, COALESCE(AVG(s.nivel_gravedad),0) AS gravedad_media
          FROM siniestros s
          JOIN tipos_siniestro t ON s.tipo_id = t.id
          GROUP BY t.nombre
          ORDER BY total DESC;
        """)
        result = await db.execute(sql)
        rows = result.mappings().all()
        return JSONResponse(content=_serialize_rows(rows))
    except ProgrammingError:
        logging.exception("Tabla 'tipos_siniestro' ausente, aplicando fallback por tipo_id")
        try:
            sql = text("""
              SELECT s.tipo_id AS tipo, COUNT(*) AS total
              FROM siniestros s
              GROUP BY s.tipo_id
              ORDER BY total DESC;
            """)
            result = await db.execute(sql)
            rows = result.mappings().all()
            return JSONResponse(content=_serialize_rows(rows))
        except Exception:
            logging.exception("Error fallback estadisticas_por_tipo")
            return JSONResponse({"detail": "Error interno"}, status_code=500)
    except Exception:
        logging.exception("Error en estadisticas_por_tipo")
        return JSONResponse({"detail": "Error interno"}, status_code=500)

@router.get("/siniestros-por-dia-semana")
async def siniestros_por_dia_semana(db: AsyncSession = Depends(get_db)):
    """
    Compatible con MariaDB/MySQL: WEEKDAY(fecha) devuelve 0=Monday..6=Sunday,
    sumamos 1 para obtener ISO 1..7.
    """
    try:
        sql = text("""
          SELECT (WEEKDAY(fecha) + 1) AS dia_semana, COUNT(*) AS total
          FROM siniestros
          GROUP BY dia_semana
          ORDER BY dia_semana;
        """)
        result = await db.execute(sql)
        rows = result.mappings().all()
        return JSONResponse(content=_serialize_rows(rows))
    except Exception:
        logging.exception("Error en siniestros_por_dia_semana")
        return JSONResponse({"detail": "Error interno"}, status_code=500)

# Nuevo endpoint solicitado por el frontend
@router.get("/estadisticas")
async def estadisticas(db: AsyncSession = Depends(get_db)):
    """
    Endpoint agregado para /reportes/estadisticas.
    Devuelve estadísticas agregadas (puedes ampliar la consulta según necesites).
    """
    try:
        sql = text("""
          SELECT COUNT(*) AS total_siniestros,
                 COALESCE(SUM(victimas_fatales),0) AS total_fallecidos,
                 COALESCE(SUM(heridos),0) AS total_heridos
          FROM siniestros;
        """)
        result = await db.execute(sql)
        row = result.mappings().first()
        return JSONResponse(content=_serialize_row(row))
    except Exception as e:
        logging.exception("Error en estadisticas")
        return JSONResponse(content={"detail": "Error interno"}, status_code=500)

# ========================================
# NUEVOS ENDPOINTS PARA ANÁLISIS DE SEGURIDAD
# ========================================
# Agregar estos endpoints al final del archivo reportes.py, antes de las notas técnicas


@router.get("/indice-seguridad")
async def obtener_indice_seguridad(
    orden: str = Query("peligrosidad", description="Ordenamiento: peligrosidad, nombre, zona"),
    limite: Optional[int] = Query(None, description="Límite de resultados"),
    db: AsyncSession = Depends(get_db),
    _: dict = Depends(obtener_usuario_actual)
):
    """
    Obtiene el índice de seguridad de todas las avenidas.
    
    Combina datos de siniestros (70%) y delitos (30%) para calcular
    un índice de peligrosidad integral.
    
    Query Parameters:
        - orden: Criterio de ordenamiento (peligrosidad, nombre, zona)
        - limite: Número máximo de resultados
    
    Returns:
        List: Lista de avenidas con su índice de seguridad
    
    Ejemplo:
        GET /reportes/indice-seguridad?orden=peligrosidad&limite=10
        → Devuelve las 10 avenidas más peligrosas
    """
    avenidas = await analisis_seguridad.obtener_indice_seguridad_avenidas(
        db, orden=orden, limite=limite
    )
    
    # Convertir a JSON serializable
    avenidas_json = jsonable_encoder(avenidas)
    
    return JSONResponse(content={
        "total": len(avenidas_json),
        "orden": orden,
        "avenidas": avenidas_json
    })


@router.get("/indice-seguridad/{avenida_id}")
async def obtener_indice_seguridad_avenida(
    avenida_id: int,
    db: AsyncSession = Depends(get_db),
    _: dict = Depends(obtener_usuario_actual)
):
    """
    Obtiene el índice de seguridad de una avenida específica.
    
    Args:
        avenida_id: ID de la avenida
    
    Returns:
        dict: Datos completos de seguridad de la avenida
    
    Raises:
        HTTPException 404: Si la avenida no existe
    """
    avenida = await analisis_seguridad.obtener_indice_seguridad_avenida(db, avenida_id)
    
    if not avenida:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Avenida no encontrada"
        )
    
    # Convertir a JSON serializable
    avenida_json = jsonable_encoder(avenida)
    
    return JSONResponse(content=avenida_json)


@router.get("/top-avenidas-seguras")
async def obtener_top_seguras(
    limite: int = Query(5, ge=1, le=20, description="Número de avenidas"),
    db: AsyncSession = Depends(get_db),
    _: dict = Depends(obtener_usuario_actual)
):
    """
    Obtiene las avenidas más seguras (menor índice de peligrosidad).
    
    Query Parameters:
        - limite: Cuántas avenidas devolver (1-20, default: 5)
    
    Returns:
        List: Las avenidas más seguras del sistema
    """
    avenidas = await analisis_seguridad.obtener_top_avenidas_seguras(db, limite)
    
    avenidas_json = jsonable_encoder(avenidas)
    
    return JSONResponse(content={
        "mensaje": f"Top {limite} avenidas más seguras",
        "avenidas": avenidas_json
    })


@router.get("/top-avenidas-peligrosas")
async def obtener_top_peligrosas(
    limite: int = Query(5, ge=1, le=20, description="Número de avenidas"),
    db: AsyncSession = Depends(get_db),
    _: dict = Depends(obtener_usuario_actual)
):
    """
    Obtiene las avenidas más peligrosas (mayor índice de peligrosidad).
    
    Query Parameters:
        - limite: Cuántas avenidas devolver (1-20, default: 5)
    
    Returns:
        List: Las avenidas más peligrosas del sistema
    """
    avenidas = await analisis_seguridad.obtener_top_avenidas_peligrosas(db, limite)
    
    avenidas_json = jsonable_encoder(avenidas)
    
    return JSONResponse(content={
        "mensaje": f"Top {limite} avenidas más peligrosas",
        "avenidas": avenidas_json
    })


@router.get("/estadisticas-seguridad")
async def obtener_estadisticas_seguridad(
    db: AsyncSession = Depends(get_db),
    _: dict = Depends(obtener_usuario_actual)
):
    """
    Obtiene estadísticas generales del sistema de seguridad.
    
    Calcula totales, promedios y distribución de riesgo en todas las avenidas.
    
    Returns:
        dict: Estadísticas agregadas del sistema
    """
    stats = await analisis_seguridad.obtener_estadisticas_generales(db)
    
    stats_json = jsonable_encoder(stats)
    
    return JSONResponse(content=stats_json)


@router.get("/comparar-avenidas")
async def comparar_avenidas(
    avenida_1: int = Query(..., description="ID de la primera avenida"),
    avenida_2: int = Query(..., description="ID de la segunda avenida"),
    db: AsyncSession = Depends(get_db),
    _: dict = Depends(obtener_usuario_actual)
):
    """
    Compara el índice de seguridad entre dos avenidas.
    
    Query Parameters:
        - avenida_1: ID de la primera avenida
        - avenida_2: ID de la segunda avenida
    
    Returns:
        dict: Comparación detallada entre ambas avenidas
    
    Raises:
        HTTPException 404: Si alguna avenida no existe
    
    Ejemplo:
        GET /reportes/comparar-avenidas?avenida_1=1&avenida_2=7
        → Compara Av. Perón vs Ruta 38
    """
    comparacion = await analisis_seguridad.comparar_avenidas(db, avenida_1, avenida_2)
    
    if not comparacion:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Una o ambas avenidas no fueron encontradas"
        )
    
    comparacion_json = jsonable_encoder(comparacion)
    
    return JSONResponse(content=comparacion_json)


# ========================================
# NOTAS DE INTEGRACIÓN
# ========================================
"""
INSTRUCCIONES PARA INTEGRAR ESTOS ENDPOINTS:

1. Abrir el archivo: backend/routers/reportes.py

2. Agregar el import al inicio del archivo:
   from services import analisis_seguridad

3. Copiar todos los endpoints de arriba (@router.get...) y pegarlos
   al final del archivo, ANTES de la sección de "NOTAS TÉCNICAS"

4. Guardar el archivo

5. Reiniciar el backend:
   python -m uvicorn main:app --reload

6. Verificar en http://127.0.0.1:8000/docs que aparezcan los nuevos endpoints:
   - GET /reportes/indice-seguridad
   - GET /reportes/indice-seguridad/{avenida_id}
   - GET /reportes/top-avenidas-seguras
   - GET /reportes/top-avenidas-peligrosas
   - GET /reportes/estadisticas-seguridad
   - GET /reportes/comparar-avenidas

CONCEPTOS APLICADOS:

1. RESTful API:
   - GET para obtener datos (nunca modifica)
   - URLs descriptivas (/indice-seguridad)
   - Query parameters para filtros (?limite=10)

2. Separación de Responsabilidades:
   - Router: Maneja HTTP requests/responses
   - Service: Contiene la lógica de negocio
   - View (SQL): Calcula los datos

3. Documentación Automática:
   - Los docstrings se muestran en /docs
   - FastAPI genera la documentación automáticamente
   - Incluye ejemplos y descripciones

4. Validación de Parámetros:
   - Query(): Define parámetros opcionales
   - ge=1, le=20: Valida rangos (greater or equal, less or equal)
   - ...: Parámetro requerido

5. Manejo de Errores:
   - HTTPException 404: Recurso no encontrado
   - HTTPException 400: Request inválido
   - Status codes estándar de HTTP
"""
